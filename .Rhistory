true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
hist(true_Phi_under)
xi_vec_y <- c(0.3, 1, -1.3, -0.3, -0.5, 0.1, 0.05)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.2, 1, -0.8, 0.2, -0.1, 0.05, 0.08)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.2, 1, -0.8, 0.2, -0.3, -0.05, 0.08)
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.2, 0.9, -0.8, 0.2, -0.3, -0.05, 0.08)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.2, 1, -0.8, 0.2, -0.3, -0.1, 0.08)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.2, 1, -0.8, 0.2, -0.3, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.2, 1, -1.2, 0.2, -0.3, -0.1, 0.05)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.2, 1, -1, 0.4, -0.4, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
summary(true_Phi_under)
hist(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.2, 1, -1, 0.4, -0.4, -0.1, 0.1)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.5, 1, -1, 0.4, -0.4, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.5, 1, -1, 0.5, -0.4, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.5, 1, -0.9, 0.5, -0.4, -0.2, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.5, 1, -0.9, 0.4, -0.5, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.5, 1, -1.1, 0.4, -0.4, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
hist(true_Phi_under[pop$c_all == 1])
hist(true_Phi_under[pop$c_all == 2])
hist(true_Phi_under[pop$c_all == 3])
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.5, 1, -0.9, 0.4, -0.3, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
log(-0.5)
exp(-0.5)
exp(-0.7)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.7, 1, -0.9, 0.4, -0.3, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.7, 1, -0.8, 0.4, -0.3, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.6, 1, -0.8, 0.4, -0.3, -0.1, 0.05)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.6, 1, -0.8, 0.4, -0.3, -0.1, 0.06)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
exp(0.06)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.6, 1, -0.8, 0.4, -0.3, -0.1, 0.09)
summary(pop)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.6, 1, -0.8, 0.4, -0.3, -0.1, 0.09)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.6, 1, -0.9, 0.4, -0.3, -0.1, 0.1)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.6, 1, -0.9, 0.4, -0.3, -0.1, 0.1)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
summary(Y_data)
# Source simulation functions
source(paste0(wd, code_dir, "simulate_data_functions.R"))
scenario <- 0
# Create data folder if it doesn't exist
dir_path <- paste0(wd, data_dir, "scen_", scenario, "/")
if (!dir.exists(dir_path)) {
dir.create(file.path(dir_path))
}
### General parameters
rho <- 0.5     # Correlation between selection variables A1 and A2
N <- 40000     # Population size
pop_seed <- 1  # Set seed
### Parameters for generating categorical latent class assignment C
formula_c <- "~ A1 + A2 + A1A2"
beta_mat_c <- matrix(c(0, 0, 0, 0,
0.4, -0.5, 0.75, 0.1,
-0.2, -1, 1.2, 0.25), nrow = 3, byrow = TRUE)
colnames(beta_mat_c) <- c("Intercept", "A1", "A2", "A1A2")
### Parameters for generating observed manifest variables X
J <- 30; R <- 4; K <- 3
formula_x <- "~ c_all"
V_unique <- data.frame(c_all = as.factor(1:K))
profiles <- as.matrix(data.frame(C1 = c(rep(1, times = 0.5 * J),
rep(3, times = 0.5 * J)),
C2 = c(rep(4, times = 0.2 * J),
rep(2, times = 0.8 * J)),
C3 = c(rep(3, times = 0.3 * J),
rep(4, times = 0.4 * J),
rep(1, times = 0.3 * J))))
modal_theta_prob <- 0.85
beta_list_x_temp <- get_betas_x(profiles = profiles, R = R,
modal_theta_prob = modal_theta_prob,
formula_x = formula_x, V_unique = V_unique)
# Add in coefficients for A3, updating formula_x and beta_list_x
formula_x <- "~ c_all + A1 + A3 + c_all:A1"
# Items 1-2 are affected in the following manner:
# level 2 probability increases as A3 increases
beta_list_x <- lapply(1:2, function(j) cbind(beta_list_x_temp[[j]],
A1 = rep(0, 4),
A3 = c(0, 0.5, 0, 0),
`c_all2:A1` = rep(0, 4),
`c_all3:A1` = rep(0, 4)))
beta_list_x <- c(beta_list_x, lapply(3:(J-2), function(j)
cbind(beta_list_x_temp[[j]], A1 = rep(0, 4), A3 = rep(0, 4),
`c_all2:A1` = rep(0, 4),
`c_all3:A1` = rep(0, 4))))
# Items 29-30 are affected as follows: A1 associated with r=3 for k=1,
# r=2 for k=2, and r=1 for k=3
beta_list_x <- c(beta_list_x, lapply((J-1):J, function(j)
cbind(beta_list_x_temp[[j]], A1 = c(0, 0, 2, 0), A3 = rep(0, 4),
`c_all2:A1` = c(0, 2, -2, 0), `c_all3:A1` = c(0, -1, -2, -1))))
# V_unique <- as.data.frame(expand.grid(c_all = as.factor(1:K),
#                                       A1 = c(-4, 0, 4),
#                                       A3 = c(-8, 0, 8)))
# round(get_categ_probs(beta_mat = beta_list_x[[1]], formula = formula_x,
#                       V_unique = V_unique), 3)
### Parameters for generating binary outcome variable Y
formula_y <- "~ c_all + A1 + A2 + c_all:A1"
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.6, 1, -0.9, 0.4, -0.3, -0.1, 0.1)
### Generate population
n_B <- 2000  # Sample size for non-probability sample
n_R <- 2000  # Sample size for reference sample
sim_pop <- sim_pop_wolcan(N = N, J = J, K = K, R = R, rho = rho, n_B = n_B,
n_R = n_R, high_overlap = TRUE, formula_c = formula_c,
beta_mat_c = beta_mat_c, formula_x = formula_x,
beta_list_x = beta_list_x, formula_y = formula_y,
xi_vec_y = xi_vec_y, pop_seed = pop_seed,
save_res = TRUE, save_path = dir_path)
summary(sim_pop$Y_data)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.7, 1, -0.9, 0.4, -0.3, -0.1, 0.1)
### Generate population
n_B <- 2000  # Sample size for non-probability sample
n_R <- 2000  # Sample size for reference sample
sim_pop <- sim_pop_wolcan(N = N, J = J, K = K, R = R, rho = rho, n_B = n_B,
n_R = n_R, high_overlap = TRUE, formula_c = formula_c,
beta_mat_c = beta_mat_c, formula_x = formula_x,
beta_list_x = beta_list_x, formula_y = formula_y,
xi_vec_y = xi_vec_y, pop_seed = pop_seed,
save_res = TRUE, save_path = dir_path)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
summary(sim_pop$Y_data)
# xi0 + xi1*I(C=2) + xi2*I(C=3) + xi3*A1 + xi4*A2 + xi5*I(C=2):A1 + xi6*I(C=3):A1
xi_vec_y <- c(-0.65, 1, -0.9, 0.4, -0.3, -0.1, 0.1)
### Generate population
n_B <- 2000  # Sample size for non-probability sample
n_R <- 2000  # Sample size for reference sample
sim_pop <- sim_pop_wolcan(N = N, J = J, K = K, R = R, rho = rho, n_B = n_B,
n_R = n_R, high_overlap = TRUE, formula_c = formula_c,
beta_mat_c = beta_mat_c, formula_x = formula_x,
beta_list_x = beta_list_x, formula_y = formula_y,
xi_vec_y = xi_vec_y, pop_seed = pop_seed,
save_res = TRUE, save_path = dir_path)
# Design matrix
design_mat_y <- stats::model.matrix(stats::as.formula(formula_y), data = pop)
# Get vector of individual linear predictors
lin_pred <- design_mat_y %*% xi_vec_y
# Get vector of individual underlying outcome probabilities
true_Phi_under <- exp(lin_pred) / (1 + exp(lin_pred))
# Outcome data
Y_data <- stats::rbinom(n = N, size = 1, prob = true_Phi_under)
hist(true_Phi_under)
summary(true_Phi_under)
summary(sim_pop$Y_data)
prop.table(table(sim_pop$c_all))
summary(sim_pop$Y_data)
# Source simulation functions
source(paste0(wd, code_dir, "simulate_data_functions.R"))
### Generate samples
num_samps <- 100  # Number of samples
for (i in 1:num_samps) {
sim_samps <- sim_samp_wolcan(i = i, sim_pop = sim_pop,
scenario = scenario, save_res = TRUE, samp_seed = i,
save_path = dir_path)
}
load("~/Documents/GitHub/WOLCAN/Data/scen_0/sim_samp_1_B_wolcan.RData")
summary(sim_samp_B$Y_data)
#================== Run simulations and summary for outcome model ==============
pop$Y <- Y_data
test <- glm(as.formula(Y ~ c_all + A1 + A2 + c_all:A1), data = pop,
family = binomial(link = "logit"))
summary(test)$coefficients[, 1]
xi_vec_y
test <- glm(as.formula(Y ~ c_all + A1 + A2 + c_all:A1), data = sim_samp_B,
family = binomial(link = "logit"))
test <- glm(as.formula(Y_data ~ c_all + A1 + A2 + c_all:A1), data = sim_samp_B,
family = binomial(link = "logit"))
test <- glm(as.formula(sim_samp_B$Y_data ~ c_all + A1 + A2 + c_all:A1), data = sim_samp_B$covs,
family = binomial(link = "logit"))
test <- glm(as.formula(sim_samp_B$Y_data ~ sim_samp_B$c_all + A1 + A2 + sim_samp_B$c_all:A1), data = sim_samp_B$covs,
family = binomial(link = "logit"))
summary(test)$coefficients[, 1]
xi_vec_y
#================== Run simulations and summary for outcome model ==============
library(survey)
svy_des <- svydesign(id=~1, weights = ~(1/sim_samp_B$true_pi_B), data = samp_data)
samp_data <- data.frame(c_all = sim_samp_B$c_all, Y = sim_samp_B$Y_data,
sim_samp_B$covs)
svy_des <- svydesign(id=~1, weights = ~(1/sim_samp_B$true_pi_B), data = samp_data)
svy_test <- survey::svyglm(formula = as.formula(Y ~ c_all + A1 + A2 + c_all:A1),
design = svy_des)
summary(svy_test)
summary(svy_test)$coefficients[, 1]
# True parameters
xi_vec_y
samp_data <- data.frame(c_all = sim_samp_B$c_all, Y = sim_samp_B$Y_data,
sim_samp_B$covs, wts = 1/sim_samp_B$true_pi_B,
clus = 1:nrow(sim_samp_B))
svy_des <- survey::svydesign(ids = ~clus, weights = ~wts, data = samp_data)
samp_data <- data.frame(c_all = sim_samp_B$c_all, Y = sim_samp_B$Y_data,
sim_samp_B$covs, wts = 1/sim_samp_B$true_pi_B,
clus = 1:nrow(sim_samp_B$covs))
svy_des <- survey::svydesign(ids = ~clus, weights = ~wts, data = samp_data)
svy_test <- survey::svyglm(formula = as.formula(Y ~ c_all + A1 + A2 + c_all:A1),
design = svy_des,
family = stats::binomial(link = "logit"))
svy_des <- survey::svydesign(ids = ~clus, weights = ~wts, data = samp_data)
svy_test <- survey::svyglm(formula = as.formula(Y ~ c_all + A1 + A2 + c_all:A1),
design = svy_des,
family = stats::binomial(link = "logit"))
summary(svy_test)$coefficients[, 1]
samp_data <- data.frame(c_all = sim_samp_B$c_all, Y = sim_samp_B$Y_data,
sim_samp_B$covs, wts = round(1/sim_samp_B$true_pi_B),
clus = 1:nrow(sim_samp_B$covs))
svy_des <- survey::svydesign(ids = ~clus, weights = ~wts, data = samp_data)
svy_test <- survey::svyglm(formula = as.formula(Y ~ c_all + A1 + A2 + c_all:A1),
design = svy_des,
family = stats::binomial(link = "logit"))
samp_data <- data.frame(c_all = sim_samp_B$c_all, Y = sim_samp_B$Y_data,
sim_samp_B$covs, wts = 1/sim_samp_B$true_pi_B,
clus = 1:nrow(sim_samp_B$covs))
svy_des <- survey::svydesign(ids = ~clus, weights = ~wts, data = samp_data)
svy_test <- survey::svyglm(formula = as.formula(Y ~ c_all + A1 + A2 + c_all:A1),
design = svy_des,
family = stats::binomial(link = "logit"))
summary(svy_test)$coefficients[, 1]
# True parameters
xi_vec_y
summary(test)$coefficients[, 1]
round(summary(test)$coefficients[, 1], 3)
round(summary(svy_test)$coefficients[, 1], 3)
# True parameters
xi_vec_y
mean(abs(xi_vec_y - summary(test)$coefficients[, 1]))
mean(abs(xi_vec_y - summary(svy_test)$coefficients[, 1]))
svy_des <- survey::svydesign(ids = ~clus, weights = ~1, data = samp_data)
svy_test <- survey::svyglm(formula = as.formula(Y ~ c_all + A1 + A2 + c_all:A1),
design = svy_des,
family = stats::binomial(link = "logit"))
round(summary(svy_test)$coefficients[, 1], 3)
# True parameters
xi_vec_y
mean(abs(xi_vec_y - summary(svy_test)$coefficients[, 1]))
svy_des <- survey::svydesign(ids = ~clus, weights = ~wts, data = samp_data)
svy_test <- survey::svyglm(formula = as.formula(Y ~ c_all + A1 + A2 + c_all:A1),
design = svy_des,
family = stats::binomial(link = "logit"))
svy_test$coefficients
confint(svy_test)
confint(test)
xi_vec_y
test <- glm(as.formula(Y ~ c_all), data = pop,
family = binomial(link = "logit"))
test <- glm(as.formula(Y ~ c_all + A1 + A2 + c_all:A1), data = pop,
family = binomial(link = "logit"))
sum(c(401, 76, 378, 100, 109, 87, 142, 185))
26/1478
76/1478
wd <- "~/Documents/GitHub/WOLCAN/"  # Working directory
data_dir <- "Data/"    # Data directory
res_dir <- "Results/"  # Results directory
code_dir <- "Summary_Code/"  # Model code directory
sum_dir <- "Summary_Results/"  # Summary results directory
# Source summary functions
source(paste0(wd, code_dir, "summary_functions.R"))
wd <- "~/Documents/GitHub/WOLCAN/"  # Working directory
data_dir <- "Data/"    # Data directory
res_dir <- "Results/"  # Results directory
code_dir <- "Summary_Code/"  # Model code directory
sum_dir <- "Summary_Results/"  # Summary results directory
## Test code
formula_y <- "y_all ~ c_all + A1 + A2 + c_all:A1"
load(paste0(wd, res_dir, "scen_0/samp_2_wolcan_results.RData"))
load(paste0(wd, res_dir, "scen_0/samp_1_wolcan_results.RData"))
n <- res$data_vars$n
y_all <- sim_samp_B$Y_data
load(paste0(wd, data_dir, "scen_0/sim_samp_1_B_wolcan.RData"))
load(paste0(wd, data_dir, "scen_0/sim_samp_1_R_wolcan.RData"))
load(paste0(wd, res_dir, "scen_0/samp_1_wolcan_results.RData"))
n <- res$data_vars$n
y_all <- sim_samp_B$Y_data
w_all <- res$data_vars$w_all
svy_data <- data.frame(c_all = as.factor(res$estimates_adjust$c_all),
y_all = y_all,
A1 = sim_samp_B$covs$A1,
A2 = sim_samp_B$covs$A2,
w_all = w_all,
cluster_id = 1:n)
V <- model.matrix(as.formula(formula_y), data = svy_data)
q <- ncol(V)
data_stan <- list(n = n, q = q, y = y_all, V = V, weights = w_all)
par_stan <- c('xi')  # subset of parameters interested in
# Compile stan model
mod_stan <- rstan::stan_model(file = paste0(wd, "Model_Code/wtd_logistic.stan"))
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
out_stan <- rstan::sampling(object = mod_stan, data = data_stan,
pars = par_stan)
# Compile stan model
mod_stan <- rstan::stan_model(file = paste0(wd, "Model_Code/wtd_logistic.stan"))
out_stan <- rstan::sampling(object = mod_stan, data = data_stan,
pars = par_stan)
