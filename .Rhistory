sum(samp_df$weight)
# Generate synthetic population using the derived formula in Algorithm 1 of
# Gunawan et al. (2020)
l_boot = numeric(n)
idx_select = numeric(N-n)
for (k in 1:(N-n)) {
new_weights_num = weights - 1 + l_boot * Nnn
new_weights_denom = N - n + (k - 1) * Nnn
new_weights = new_weights_num / new_weights_denom
idx = sample(1:n, 1, replace = TRUE, prob = (new_weights) / sum(new_weights))
idx_select[k] = idx
l_boot[idx] = l_boot[idx] + 1
}
synth_pop = c(1:n, idx_select)
# Calculate estimated value for mean(y)
y_bar_gunawan[m] <- sum(samp_df$y_samp[synth_pop])/N
}
start3 <- Sys.time()
#====== Test code specifying weighted Polya posterior from scratch =============
# Initialize estimated mean(y) for each synthetic population run
y_bar_cwpolya <- numeric(M)
# For each simulation run, calculated the estimated population mean
for (m in 1:M) {
# Print progress
if (m %% 50 == 0) {
print(paste0("Running simulation ", m))
}
set.seed(m)
# Draw a sample of size 100 using sampling weights
samp_id <- sample(x = pop_df$id, size = n, replace = FALSE, prob = pop_df$prob)
# Create sample data
samp_df <- data.frame(
pop_id = samp_id,
y_samp = pop_df$y[samp_id],
weight = 1/pop_df$prob[samp_id]
)
# Re-normalize weights to sum to population
samp_df$weight <- samp_df$weight * (N / sum(samp_df$weight))
sum(samp_df$weight)
# Generate synthetic population
w = cumsum(weights)
# Initialize vector of imputed indices
synth_pop = numeric(N)
# First n values of the synthetic population are the sample data
synth_pop[1:n] = samp_df$y_samp
for (i in 1:(N-n)) {  # For each non-sampled unit
# Generate a weighted Polya draw
a = w[n] * runif(1)  # Random number from 0 to sum(weights)
j = 1                # j is first index with a <= cumsum
while (a > w[j]) {
j = j + 1
}
# To represent adding another ball of the same color, increment all cumsum
# values starting from the j-th value
for (k in j:n) {
w[k] = w[k] + 1
}
# Index indicates i-th imputed unit has same value as j-th sample unit
# Add the imputed data to the synthetic population
synth_pop[n + i] = samp_df$y_samp[j]
}
# Calculate estimated value for mean(y)
y_bar_cwpolya[m] <- sum(synth_pop) / N
}
start4 <- Sys.time()
# True mean(y)
mean(pop_df$y)
mean(y_bar_package)
mean(y_bar_gunawan)
mean(y_bar_cwpolya)
# Runtimes
start2 - start
start3 - start2
start4 - start3
M = 100
# ==============================================================================
# Testing equivalence of Polya sampling implementations
#
# This file tests three implementations of sampling from a weighted Polya
# posterior to generate a synthetic population and then calculate the population
# mean based on the synthetic population
#
# Date created: 2022/09/04
# Date updated: 2025/08/21
# ==============================================================================
# Load the 'polyapost' package that simulates from the Polya posterior
library(polyapost)
# Set parameters
set.seed(123)
N <- 10000 # population size
n <- 100 # sample size
M <- 100 # Number of times to run the simulation
# Create simulated population data
pop_df <- data.frame(
id = 1:N,
# Outcome variable
y = rnorm(n = N, mean = 5, sd = 2),
# Define sampling probabilities through stratified sampling
prob = c(rep(20/5000, times = 5000),
rep(30/2000, times = 2000),
rep(40/1000, times = 1000),
rep(10/2000, times = 2000))
)
# Check sample weights sum
sum(samp_df$weight)
#====== Test 'polyapost' package function ======================================
start <- Sys.time()
# Initialize estimated mean(y) for each synthetic population run
y_bar_package <- numeric(M)
# For each simulation run, calculated the estimated population mean
for (m in 1:M) {
# Print progress
if (m %% 50 == 0) {
print(paste0("Running simulation ", m))
}
set.seed(m)
# Draw a sample of size 100 using sampling weights
samp_id <- sample(x = pop_df$id, size = n, replace = FALSE, prob = pop_df$prob)
# Create sample data
samp_df <- data.frame(
pop_id = samp_id,
y_samp = pop_df$y[samp_id],
weight = 1/pop_df$prob[samp_id]
)
# Re-normalize weights to sum to population
samp_df$weight <- samp_df$weight * (N / sum(samp_df$weight))
sum(samp_df$weight)
# Generate synthetic population
synth_pop = polyapost::wtpolyap(samp_df$y_samp, weights, k = N-n)
# Calculate estimated value for mean(y)
y_bar_package[m] = sum(synth_pop) / N
}
start2 <- Sys.time()
#====== Test code from Gunawan et al. (2020) ===================================
# Citation:
# Gunawan, D., Panagiotelis, A., Griffiths, W., & Chotikapanich, D.
# (2020). Bayesian weighted inference from surveys. Australian & New Zealand
# Journal of Statistics, 62(1), 71-94.
# Initialize estimated mean(y) for each synthetic population run
y_bar_gunawan <- numeric(M)
Nnn <- (N - n) / n
# For each simulation run, calculated the estimated population mean
for (m in 1:M) {
# Print progress
if (m %% 50 == 0) {
print(paste0("Running simulation ", m))
}
set.seed(m)
# Draw a sample of size 100 using sampling weights
samp_id <- sample(x = pop_df$id, size = n, replace = FALSE, prob = pop_df$prob)
# Create sample data
samp_df <- data.frame(
pop_id = samp_id,
y_samp = pop_df$y[samp_id],
weight = 1/pop_df$prob[samp_id]
)
# Re-normalize weights to sum to population
samp_df$weight <- samp_df$weight * (N / sum(samp_df$weight))
sum(samp_df$weight)
# Generate synthetic population using the derived formula in Algorithm 1 of
# Gunawan et al. (2020)
l_boot = numeric(n)
idx_select = numeric(N-n)
for (k in 1:(N-n)) {
new_weights_num = weights - 1 + l_boot * Nnn
new_weights_denom = N - n + (k - 1) * Nnn
new_weights = new_weights_num / new_weights_denom
idx = sample(1:n, 1, replace = TRUE, prob = (new_weights) / sum(new_weights))
idx_select[k] = idx
l_boot[idx] = l_boot[idx] + 1
}
synth_pop = c(1:n, idx_select)
# Calculate estimated value for mean(y)
y_bar_gunawan[m] <- sum(samp_df$y_samp[synth_pop])/N
}
start3 <- Sys.time()
#====== Test code specifying weighted Polya posterior from scratch =============
# Initialize estimated mean(y) for each synthetic population run
y_bar_cwpolya <- numeric(M)
# For each simulation run, calculated the estimated population mean
for (m in 1:M) {
# Print progress
if (m %% 50 == 0) {
print(paste0("Running simulation ", m))
}
set.seed(m)
# Draw a sample of size 100 using sampling weights
samp_id <- sample(x = pop_df$id, size = n, replace = FALSE, prob = pop_df$prob)
# Create sample data
samp_df <- data.frame(
pop_id = samp_id,
y_samp = pop_df$y[samp_id],
weight = 1/pop_df$prob[samp_id]
)
# Re-normalize weights to sum to population
samp_df$weight <- samp_df$weight * (N / sum(samp_df$weight))
sum(samp_df$weight)
# Generate synthetic population
w = cumsum(weights)
# Initialize vector of imputed indices
synth_pop = numeric(N)
# First n values of the synthetic population are the sample data
synth_pop[1:n] = samp_df$y_samp
for (i in 1:(N-n)) {  # For each non-sampled unit
# Generate a weighted Polya draw
a = w[n] * runif(1)  # Random number from 0 to sum(weights)
j = 1                # j is first index with a <= cumsum
while (a > w[j]) {
j = j + 1
}
# To represent adding another ball of the same color, increment all cumsum
# values starting from the j-th value
for (k in j:n) {
w[k] = w[k] + 1
}
# Index indicates i-th imputed unit has same value as j-th sample unit
# Add the imputed data to the synthetic population
synth_pop[n + i] = samp_df$y_samp[j]
}
# Calculate estimated value for mean(y)
y_bar_cwpolya[m] <- sum(synth_pop) / N
}
start4 <- Sys.time()
#=========== Assess results
# True mean(y): 4.995
mean(pop_df$y)
mean(y_bar_package)
# M=100:3.6402
# M=1000: 5.005 (3.8 secs)
# M=10000: 3.6452 (0.54 secs)
mean(y_bar_gunawan)
# M=100: 3.74973
# M=1000: 5.004 (58.5 secs)
# M=10000: 3.671469 (10.25 secs)
mean(y_bar_cwpolya)
# M=100: 3.6402
# M=1000: 5.005 (41.4 secs)
# M=10000: 3.6452 (4.94 secs)
# Runtimes
start2 - start
start3 - start2
start4 - start3
# Load the 'polyapost' package that simulates from the Polya posterior
library(polyapost)
# Set parameters
set.seed(123)
N <- 10000 # population size
n <- 100 # sample size
M <- 10000 # Number of times to run the simulation
# Create simulated population data
pop_df <- data.frame(
id = 1:N,
# Outcome variable
y = rnorm(n = N, mean = 5, sd = 2),
# Define sampling probabilities through stratified sampling
prob = c(rep(20/5000, times = 5000),
rep(30/2000, times = 2000),
rep(40/1000, times = 1000),
rep(10/2000, times = 2000))
)
# Check sample weights sum
sum(samp_df$weight)
#====== Test 'polyapost' package function ======================================
start <- Sys.time()
# Initialize estimated mean(y) for each synthetic population run
y_bar_package <- numeric(M)
# For each simulation run, calculated the estimated population mean
for (m in 1:M) {
# Print progress
if (m %% 50 == 0) {
print(paste0("Running simulation ", m))
}
set.seed(m)
# Draw a sample of size 100 using sampling weights
samp_id <- sample(x = pop_df$id, size = n, replace = FALSE, prob = pop_df$prob)
# Create sample data
samp_df <- data.frame(
pop_id = samp_id,
y_samp = pop_df$y[samp_id],
weight = 1/pop_df$prob[samp_id]
)
# Re-normalize weights to sum to population
samp_df$weight <- samp_df$weight * (N / sum(samp_df$weight))
sum(samp_df$weight)
# Generate synthetic population
synth_pop = polyapost::wtpolyap(samp_df$y_samp, weights, k = N-n)
# Calculate estimated value for mean(y)
y_bar_package[m] = sum(synth_pop) / N
}
start2 <- Sys.time()
#====== Test code from Gunawan et al. (2020) ===================================
# Citation:
# Gunawan, D., Panagiotelis, A., Griffiths, W., & Chotikapanich, D.
# (2020). Bayesian weighted inference from surveys. Australian & New Zealand
# Journal of Statistics, 62(1), 71-94.
# Initialize estimated mean(y) for each synthetic population run
y_bar_gunawan <- numeric(M)
Nnn <- (N - n) / n
# For each simulation run, calculated the estimated population mean
for (m in 1:M) {
# Print progress
if (m %% 50 == 0) {
print(paste0("Running simulation ", m))
}
set.seed(m)
# Draw a sample of size 100 using sampling weights
samp_id <- sample(x = pop_df$id, size = n, replace = FALSE, prob = pop_df$prob)
# Create sample data
samp_df <- data.frame(
pop_id = samp_id,
y_samp = pop_df$y[samp_id],
weight = 1/pop_df$prob[samp_id]
)
# Re-normalize weights to sum to population
samp_df$weight <- samp_df$weight * (N / sum(samp_df$weight))
sum(samp_df$weight)
# Generate synthetic population using the derived formula in Algorithm 1 of
# Gunawan et al. (2020)
l_boot = numeric(n)
idx_select = numeric(N-n)
for (k in 1:(N-n)) {
new_weights_num = weights - 1 + l_boot * Nnn
new_weights_denom = N - n + (k - 1) * Nnn
new_weights = new_weights_num / new_weights_denom
idx = sample(1:n, 1, replace = TRUE, prob = (new_weights) / sum(new_weights))
idx_select[k] = idx
l_boot[idx] = l_boot[idx] + 1
}
synth_pop = c(1:n, idx_select)
# Calculate estimated value for mean(y)
y_bar_gunawan[m] <- sum(samp_df$y_samp[synth_pop])/N
}
# ==============================================================================
# Testing equivalence of Polya sampling implementations
#
# This file tests three implementations of sampling from a weighted Polya
# posterior to generate a synthetic population and then calculate the population
# mean based on the synthetic population
#
# Date created: 2022/09/04
# Date updated: 2025/08/21
# ==============================================================================
# Load the 'polyapost' package that simulates from the Polya posterior
library(polyapost)
# Set parameters
set.seed(123)
N <- 10000 # population size
n <- 100 # sample size
M <- 5000 # Number of times to run the simulation
# Create simulated population data
pop_df <- data.frame(
id = 1:N,
# Outcome variable
y = rnorm(n = N, mean = 5, sd = 2),
# Define sampling probabilities through stratified sampling
prob = c(rep(20/5000, times = 5000),
rep(30/2000, times = 2000),
rep(40/1000, times = 1000),
rep(10/2000, times = 2000))
)
# Check sample weights sum
sum(samp_df$weight)
#====== Test 'polyapost' package function ======================================
start <- Sys.time()
# Initialize estimated mean(y) for each synthetic population run
y_bar_package <- numeric(M)
# For each simulation run, calculated the estimated population mean
for (m in 1:M) {
# Print progress
if (m %% 50 == 0) {
print(paste0("Running simulation ", m))
}
set.seed(m)
# Draw a sample of size 100 using sampling weights
samp_id <- sample(x = pop_df$id, size = n, replace = FALSE, prob = pop_df$prob)
# Create sample data
samp_df <- data.frame(
pop_id = samp_id,
y_samp = pop_df$y[samp_id],
weight = 1/pop_df$prob[samp_id]
)
# Re-normalize weights to sum to population
samp_df$weight <- samp_df$weight * (N / sum(samp_df$weight))
sum(samp_df$weight)
# Generate synthetic population
synth_pop = polyapost::wtpolyap(samp_df$y_samp, weights, k = N-n)
# Calculate estimated value for mean(y)
y_bar_package[m] = sum(synth_pop) / N
}
start2 <- Sys.time()
#====== Test code from Gunawan et al. (2020) ===================================
# Citation:
# Gunawan, D., Panagiotelis, A., Griffiths, W., & Chotikapanich, D.
# (2020). Bayesian weighted inference from surveys. Australian & New Zealand
# Journal of Statistics, 62(1), 71-94.
# Initialize estimated mean(y) for each synthetic population run
y_bar_gunawan <- numeric(M)
Nnn <- (N - n) / n
# For each simulation run, calculated the estimated population mean
for (m in 1:M) {
# Print progress
if (m %% 50 == 0) {
print(paste0("Running simulation ", m))
}
set.seed(m)
# Draw a sample of size 100 using sampling weights
samp_id <- sample(x = pop_df$id, size = n, replace = FALSE, prob = pop_df$prob)
# Create sample data
samp_df <- data.frame(
pop_id = samp_id,
y_samp = pop_df$y[samp_id],
weight = 1/pop_df$prob[samp_id]
)
# Re-normalize weights to sum to population
samp_df$weight <- samp_df$weight * (N / sum(samp_df$weight))
sum(samp_df$weight)
# Generate synthetic population using the derived formula in Algorithm 1 of
# Gunawan et al. (2020)
l_boot = numeric(n)
idx_select = numeric(N-n)
for (k in 1:(N-n)) {
new_weights_num = weights - 1 + l_boot * Nnn
new_weights_denom = N - n + (k - 1) * Nnn
new_weights = new_weights_num / new_weights_denom
idx = sample(1:n, 1, replace = TRUE, prob = (new_weights) / sum(new_weights))
idx_select[k] = idx
l_boot[idx] = l_boot[idx] + 1
}
synth_pop = c(1:n, idx_select)
# Calculate estimated value for mean(y)
y_bar_gunawan[m] <- sum(samp_df$y_samp[synth_pop])/N
}
start3 <- Sys.time()
#====== Test code specifying weighted Polya posterior from scratch =============
# Initialize estimated mean(y) for each synthetic population run
y_bar_cwpolya <- numeric(M)
# For each simulation run, calculated the estimated population mean
for (m in 1:M) {
# Print progress
if (m %% 50 == 0) {
print(paste0("Running simulation ", m))
}
set.seed(m)
# Draw a sample of size 100 using sampling weights
samp_id <- sample(x = pop_df$id, size = n, replace = FALSE, prob = pop_df$prob)
# Create sample data
samp_df <- data.frame(
pop_id = samp_id,
y_samp = pop_df$y[samp_id],
weight = 1/pop_df$prob[samp_id]
)
# Re-normalize weights to sum to population
samp_df$weight <- samp_df$weight * (N / sum(samp_df$weight))
sum(samp_df$weight)
# Generate synthetic population
w = cumsum(weights)
# Initialize vector of imputed indices
synth_pop = numeric(N)
# First n values of the synthetic population are the sample data
synth_pop[1:n] = samp_df$y_samp
for (i in 1:(N-n)) {  # For each non-sampled unit
# Generate a weighted Polya draw
a = w[n] * runif(1)  # Random number from 0 to sum(weights)
j = 1                # j is first index with a <= cumsum
while (a > w[j]) {
j = j + 1
}
# To represent adding another ball of the same color, increment all cumsum
# values starting from the j-th value
for (k in j:n) {
w[k] = w[k] + 1
}
# Index indicates i-th imputed unit has same value as j-th sample unit
# Add the imputed data to the synthetic population
synth_pop[n + i] = samp_df$y_samp[j]
}
# Calculate estimated value for mean(y)
y_bar_cwpolya[m] <- sum(synth_pop) / N
}
start4 <- Sys.time()
#=========== Assess results
# True mean(y): 4.995
mean(pop_df$y)
mean(y_bar_package)
# M=100: 5.024 (0.5 secs)
# M=1000: 5.005 (3.8 secs)
# M=10000: 3.6452 (0.54 secs)
mean(y_bar_gunawan)
# M=100: 5.024 (6.5 secs)
# M=1000: 5.004 (58.5 secs)
# M=10000: 3.671469 (10.25 secs)
mean(y_bar_cwpolya)
# M=100: 5.024 (4.3 secs)
# M=1000: 5.005 (41.4 secs)
# M=10000: 3.6452 (4.94 secs)
# Runtimes
start2 - start
start3 - start2
start4 - start3
mean(pop_df$y) - mean(y_bar_package)
# Absolute differences between estimated and true
abs(c(mean(pop_df$y) - mean(y_bar_package)),
c(mean(pop_df$y) - mean(y_bar_gunawan)),
c(mean(pop_df$y) - mean(y_bar_cwpolya)))
# Absolute differences between estimated and true
abs(c(mean(pop_df$y) - mean(y_bar_package),
mean(pop_df$y) - mean(y_bar_gunawan)),
mean(pop_df$y) - mean(y_bar_cwpolya))
# Absolute differences between estimated and true
abs(mean(pop_df$y) - mean(y_bar_package))
abs(mean(pop_df$y) - mean(y_bar_gunawan))
abs(mean(pop_df$y) - mean(y_bar_cwpolya))
